import * as THREE from 'three'
import { GPUComputationRenderer } from './jsm/misc/GPUComputationRenderer.js'
import standardVert from './glsl/vertex/standard.vert'
import arrowsVert from './glsl/vertex/arrows.vert'
import arrowsFrag from './glsl/frag/arrows.frag'
import drawTextureFrag from './glsl/frag/drawTexture.frag'
import drawTextureThresholdFrag from './glsl/frag/drawTextureThreshold.frag'
import advectColorFrag from './glsl/frag/advectColor.frag'
import advectVelocityFrag from './glsl/frag/advectVelocity.frag'
import addSplatFrag from './glsl/frag/addSplat.frag'
import clampColorsFrag from './glsl/frag/clampColors.frag'
import calcDivergenceFrag from './glsl/frag/calcDivergence.frag'
import jacobiIterationForPressureFrag from './glsl/frag/jacobiIterationForPressure.frag'
import subtractPressureGradientFrag from './glsl/frag/subtractPressureGradient.frag'

let options = {}

options.initVFn = options.initVFn || [
  'sin(2.0 * 3.1415 * y)',
  'sin(2.0 * 3.1415 * x)'
]

options.initCFn = options.initCFn || [
  'step(1.0, mod(floor((x + 1.0) / 0.2) + floor((y + 1.0) / 0.2), 2.0))',
  'step(1.0, mod(floor((x + 1.0) / 0.2) + floor((y + 1.0) / 0.2), 2.0))',
  'step(1.0, mod(floor((x + 1.0) / 0.2) + floor((y + 1.0) / 0.2), 2.0))'
]

if (options.threshold === undefined) {
  options.threshold = true
}

if (options.advectV === undefined) {
  options.advectV = true
}

if (options.applyPressure === undefined) {
  options.applyPressure = false
}

if (options.showArrows === undefined) {
  options.showArrows = true
}

if (options.dyeSpots === undefined) {
  options.dyeSpots = false
}

// For silly reasons, these have to be equal for now.
// This is because I assumed grid spacing was equal along
// each axis, so if you want to change these to not be equal, you'd have to
// carefully go through the code and decide which values of EPSILON should be
// 1/WIDTH, and which should be 1/HEIGHT.
const WIDTH = options.size || 400
const HEIGHT = WIDTH
const EPSILON = 1 / WIDTH

// We assume every time step will be a 120th of a second.
// The animation loop runs at 60 fps (hopefully), so we're simulating 2x
// slow-mo.
const DELTA_T = 1 / 120.0

// We arbitrarily set our fluid's density to 1 (this is rho in equations)
const DENSITY = 1.0

let scene = new THREE.Scene()
// Will need to make another camera to render the plane proportionately within a 3d scene
let camera = new THREE.OrthographicCamera(
  WIDTH / -2,
  WIDTH / 2,
  HEIGHT / 2,
  HEIGHT / -2,
  -1,
  1
)
camera.position.z = 1

let renderer = new THREE.WebGLRenderer()
renderer.setSize(window.innerWidth, window.innerHeight)
document.body.appendChild(renderer.domElement)

gpuCompute = new GPUComputationRenderer(WIDTH, WIDTH, renderer)

// Given glsl expressions for r, g, b, a mapping (x, y) -> a value, return
// a function that will paint a color generated by that function evaluated at
// every pixel of the output buffer. (x, y) will be in the range
// ([-1, 1], [-1, 1]).
function makeFunctionPainter(r, g, b, a) {
  r = r || '0.0'
  g = g || '0.0'
  b = b || '0.0'
  a = a || '0.0'

  return (
    '\
        varying vec2 textureCoord; \
        void main() { \
          float x = 2.0 * textureCoord.x - 1.0; \
          float y = 2.0 * textureCoord.y - 1.0; \
          gl_FragColor = vec4(' +
    [r, g, b, a].join(',') +
    '); \
        } \
      '
  )
}

let drawBlack = makeFunctionPainter('0.0', '0.0', '0.0', '1.0')

let velocity = gpuCompute.createTexture()
let divergence = gpuCompute.createTexture()
let pressure = gpuCompute.createTexture()
let color = gpuCompute.createTexture()

let velocityVariable = gpuCompute.addVariable(
  'velocity',
  advectVelocityFrag,
  velocity
)
let divergenceVariable = gpuCompute.addVariable(
  'divergence',
  calcDivergenceFrag,
  divergence
)
let pressureVariable = gpuCompute.addVariable(
  'pressure',
  jacobiIterationForPressureFrag,
  pressure
)
let velocityMinusPressureGradientVariable = gpuCompute.addVariable(
  'velocityMinusPressureGradient',
  subtractPressureGradientFrag,
  velocity
)
let colorVariable = gpuCompute.addVariable('divergence', advectColorFrag, color)

// this isn't going to work as written. The easiest solution would be to have two separate advection shaders to handle the different cases of input.
// also, the sampler2d uniforms in the shaders have to use the same names as declared in the addVariable(...) method.
gpuCompute.setVariableDependencies(velocityVariable, [velocityVariable])
gpuCompute.setVariableDependencies(divergenceVariable, [velocityVariable])
gpuCompute.setVariableDependencies(pressureVariable, [
  divergenceVariable,
  pressureVariable
])
gpuCompute.setVariableDependencies(pressureVariable, [
  velocityVariable,
  pressureVariable
])
gpuCompute.setVariableDependencies(colorVariable, [
  colorVariable,
  velocityMinusPressureGradientVariable
])

velocityVariable.material.uniforms['delta'] = { value: DELTA_T }
divergenceUniforms = divergenceVariable.material.uniforms
divergenceUniforms['epsilon'] = { value: EPSILON }
divergenceUniforms['deltaT'] = { value: DELTA_T }
divergenceUniforms['rho'] = { value: DENSITY }
pressureVariable.material.uniforms['epsilon'] = { value: EPSILON }
colorVariable.material.uniforms['deltaT'] = { value: DELTA_T }
